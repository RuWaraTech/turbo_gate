---
- name: Deploy TurboGate Application with Zero Downtime
  hosts: swarm_managers
  become: yes
  
  vars:
    stack_name: turbogate
    compose_file: /opt/turbogate/docker-compose.yml
    health_check_timeout: 120
    deployment_timeout: 600
    ssh_timeout: 300

  tasks:
    - name: Validate required variables
      ansible.builtin.assert:
        that:
          - secret_key is defined
          - redis_password is defined
          - domain_name is defined
          - image_tag is defined
        fail_msg: "Required variables (secret_key, redis_password, domain_name, image_tag) must be defined"

    - name: Create application directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: '0755'
      loop:
        - /opt/turbogate
        - /var/log/turbogate
        - /var/lib/turbogate/redis
        - /var/log/turbogate/nginx
        - /var/cache/nginx
        
    - name: Set correct ownership for NGINX cache directory
      ansible.builtin.file:
        path: /var/cache/nginx
        state: directory
        owner: 101
        group: 101
        mode: '0755'
        recurse: yes

    # Pre-deployment health check with proper domain
    - name: Check current deployment health
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/gateway/health"
        method: GET
        status_code: [200, 404, 502, 503]
        timeout: 10
        validate_certs: true
      register: pre_deploy_health
      failed_when: false
      changed_when: false

    - name: Display pre-deployment status
      ansible.builtin.debug:
        msg: "Current deployment status: {{ pre_deploy_health.status | default('Unknown') }}"

    # IMPROVED ZERO-DOWNTIME SECRET MANAGEMENT
    - name: Get current timestamp for versioning
      ansible.builtin.set_fact:
        secret_version: "{{ ansible_date_time.epoch }}"

    - name: Check existing secrets
      ansible.builtin.command: docker secret ls --format '{{ "{{" }}.Name{{ "}}" }}'
      register: existing_secrets
      changed_when: false
      failed_when: false

    - name: Check if services are using old secrets
      ansible.builtin.command: docker service inspect {{ item }} --format '{{ "{{" }}json .Spec.TaskTemplate.ContainerSpec.Secrets{{ "}}" }}'
      loop:
        - "{{ stack_name }}_turbogate"
        - "{{ stack_name }}_redis"
      register: service_secrets
      failed_when: false
      changed_when: false
      ignore_errors: yes

    # Create new versioned secrets without removing old ones
    - name: Create new versioned Docker secrets
      ansible.builtin.shell: |
        echo -n "{{ item.value }}" | docker secret create {{ item.name }}_v{{ secret_version }} -
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true
      register: new_secret_creation

    # If services exist and are using old secrets, update them to use new versioned secrets
    - name: Update running services with new versioned secrets
      block:
        - name: Update turbogate service with new secrets
          ansible.builtin.command: |
            docker service update \
              --secret-rm turbogate_secret_key \
              --secret-rm redis_password \
              --secret-add source=turbogate_secret_key_v{{ secret_version }},target=turbogate_secret_key \
              --secret-add source=redis_password_v{{ secret_version }},target=redis_password \
              {{ stack_name }}_turbogate
          register: turbogate_update
          failed_when: false
          when: "'turbogate_turbogate' in existing_secrets.stdout or '{{ stack_name }}_turbogate' in existing_secrets.stdout"

        - name: Update redis service with new secret
          ansible.builtin.command: |
            docker service update \
              --secret-rm redis_password \
              --secret-add source=redis_password_v{{ secret_version }},target=redis_password \
              {{ stack_name }}_redis
          register: redis_update
          failed_when: false
          when: "'turbogate_redis' in existing_secrets.stdout or '{{ stack_name }}_redis' in existing_secrets.stdout"

        - name: Wait for service updates to complete
          ansible.builtin.pause:
            seconds: 30
          when: turbogate_update is changed or redis_update is changed

      when: service_secrets.results | length > 0 and service_secrets.results[0].rc == 0

    # Clean up old unversioned secrets if they exist and are no longer in use
    - name: Clean up old unversioned secrets
      ansible.builtin.command: docker secret rm {{ item }}
      loop:
        - turbogate_secret_key
        - redis_password
      when: 
        - item in existing_secrets.stdout_lines
        - new_secret_creation is succeeded
      failed_when: false
      ignore_errors: yes

    # Create aliases for the versioned secrets (for new deployments)
    - name: Create secret aliases for compose file compatibility
      ansible.builtin.shell: |
        # Check if the unversioned secret exists
        if ! docker secret ls --format '{{ "{{" }}.Name{{ "}}" }}' | grep -q "^{{ item.name }}$"; then
          # Create a reference to the versioned secret
          echo -n "{{ item.value }}" | docker secret create {{ item.name }} -
        fi
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true
      failed_when: false

    # IMPROVED NGINX CONFIG MANAGEMENT WITH VERSIONING
    - name: Create NGINX configuration content
      ansible.builtin.template:
        src: nginx.conf.j2 
        dest: /tmp/nginx.conf
        owner: root
        group: root
        mode: '0644'

    - name: Check existing nginx configs
      ansible.builtin.command: docker config ls --format '{{ "{{" }}.Name{{ "}}" }}'
      register: existing_configs
      changed_when: false
      failed_when: false

    - name: Create versioned NGINX config
      ansible.builtin.command: docker config create nginx_config_v{{ secret_version }} /tmp/nginx.conf
      register: nginx_config_creation

    - name: Check if nginx service exists and uses old config
      ansible.builtin.command: docker service inspect {{ stack_name }}_nginx --format '{{ "{{" }}json .Spec.TaskTemplate.ContainerSpec.Configs{{ "}}" }}'
      register: nginx_service_config
      failed_when: false
      changed_when: false
      ignore_errors: yes

    - name: Update nginx service with new versioned config
      ansible.builtin.command: |
        docker service update \
          --config-rm nginx_config \
          --config-add source=nginx_config_v{{ secret_version }},target=/etc/nginx/nginx.conf \
          {{ stack_name }}_nginx
      when: 
        - nginx_service_config.rc == 0
        - "'nginx_config' in nginx_service_config.stdout"
      failed_when: false
      register: nginx_config_update

    - name: Wait for nginx config update to complete
      ansible.builtin.pause:
        seconds: 15
      when: nginx_config_update is changed

    - name: Clean up old unversioned nginx config
      ansible.builtin.command: docker config rm nginx_config
      when: 
        - "'nginx_config' in existing_configs.stdout_lines"
        - nginx_config_creation is succeeded
      failed_when: false
      ignore_errors: yes

    - name: Create nginx config alias for new deployments
      ansible.builtin.command: docker config create nginx_config /tmp/nginx.conf
      when: "'nginx_config' not in existing_configs.stdout_lines"
      failed_when: false
      ignore_errors: yes

    - name: Clean up temporary nginx config file
      ansible.builtin.file:
        path: /tmp/nginx.conf
        state: absent
    
    - name: Verify overlay network exists
      community.docker.docker_network:
        name: turbogate_network
        driver: overlay
        attachable: yes
        state: present
    
    - name: Create Docker Compose file
      ansible.builtin.template:
        src: docker-compose.yml.j2
        dest: "{{ compose_file }}"
        owner: root
        group: root
        mode: '0644'
        backup: yes
    
    # Docker Swarm will automatically pull images during deployment
    # No pre-pulling needed - this prevents SSH timeouts and unnecessary complexity

    # Check current stack state
    - name: Check current stack status
      ansible.builtin.command: docker stack ls --format '{{ "{{" }}.Name{{ "}}" }}'
      register: existing_stacks
      changed_when: false

    - name: Get current service info if stack exists
      ansible.builtin.command: |
        docker service inspect {{ stack_name }}_turbogate --format '{{ "{{" }}.Spec.TaskTemplate.ContainerSpec.Image{{ "}}" }}'
      register: current_image
      when: stack_name in existing_stacks.stdout_lines
      failed_when: false
      changed_when: false

    - name: Display current vs new image
      ansible.builtin.debug:
        msg:
          - "Current image: {{ current_image.stdout | default('None') }}"
          - "New image: {{ docker_registry | default('docker.io') }}/{{ image_name | default('fwande/turbogate') }}:{{ image_tag }}"
      when: current_image is defined

    # Zero-downtime deployment strategy with better error handling
    - name: Deploy or update Docker stack with zero downtime
      block:
        - name: Deploy Docker stack
          community.docker.docker_stack:
            name: "{{ stack_name }}"
            compose:
              - "{{ compose_file }}"
            state: present
            prune: yes
          register: stack_deploy
          timeout: "{{ deployment_timeout }}"

        - name: Wait for initial deployment to stabilize
          ansible.builtin.pause:
            seconds: 45

        - name: Monitor deployment progress with detailed logging
          ansible.builtin.shell: |
            echo "=== Checking Service Replicas ==="
            TURBOGATE_DESIRED=$(docker service inspect {{ stack_name }}_turbogate --format '{{ "{{" }}.Spec.Mode.Replicated.Replicas{{ "}}" }}' 2>/dev/null || echo "0")
            REDIS_DESIRED=$(docker service inspect {{ stack_name }}_redis --format '{{ "{{" }}.Spec.Mode.Replicated.Replicas{{ "}}" }}' 2>/dev/null || echo "0")
            NGINX_DESIRED=$(docker service inspect {{ stack_name }}_nginx --format '{{ "{{" }}.Spec.Mode.Replicated.Replicas{{ "}}" }}' 2>/dev/null || echo "0")
            
            echo "Desired replicas - TurboGate: $TURBOGATE_DESIRED, Redis: $REDIS_DESIRED, NGINX: $NGINX_DESIRED"
            
            # Count running tasks
            TURBOGATE_RUNNING=$(docker service ps {{ stack_name }}_turbogate --filter "desired-state=running" --format "{{ "{{" }}.CurrentState{{ "}}" }}" 2>/dev/null | grep -c "Running" || echo "0")
            REDIS_RUNNING=$(docker service ps {{ stack_name }}_redis --filter "desired-state=running" --format "{{ "{{" }}.CurrentState{{ "}}" }}" 2>/dev/null | grep -c "Running" || echo "0")
            NGINX_RUNNING=$(docker service ps {{ stack_name }}_nginx --filter "desired-state=running" --format "{{ "{{" }}.CurrentState{{ "}}" }}" 2>/dev/null | grep -c "Running" || echo "0")
            
            echo "Running replicas - TurboGate: $TURBOGATE_RUNNING/$TURBOGATE_DESIRED, Redis: $REDIS_RUNNING/$REDIS_DESIRED, NGINX: $NGINX_RUNNING/$NGINX_DESIRED"
            
            # Check for any failed tasks
            FAILED_TASKS=$(docker service ps {{ stack_name }}_turbogate --filter "desired-state=running" --format "{{ "{{" }}.CurrentState{{ "}}" }}" 2>/dev/null | grep -c "Failed" || echo "0")
            if [ "$FAILED_TASKS" -gt 0 ]; then
              echo "WARNING: $FAILED_TASKS failed tasks detected"
              docker service ps {{ stack_name }}_turbogate --filter "desired-state=running" --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.Error{{ "}}" }}"
            fi
            
            # Return success if all services have at least minimum running replicas
            if [ "$TURBOGATE_RUNNING" -ge "1" ] && [ "$REDIS_RUNNING" -ge "1" ] && [ "$NGINX_RUNNING" -ge "1" ]; then
              if [ "$TURBOGATE_RUNNING" -ge "$TURBOGATE_DESIRED" ] && [ "$REDIS_RUNNING" -ge "$REDIS_DESIRED" ] && [ "$NGINX_RUNNING" -ge "$NGINX_DESIRED" ]; then
                echo "SUCCESS: All services at desired replica count"
                exit 0
              else
                echo "PARTIAL: Services running but not at full capacity"
                exit 2
              fi
            else
              echo "FAILED: Critical services not running"
              exit 1
            fi
          register: deployment_status
          retries: 5
          delay: 1
          until: deployment_status.rc == 0 or deployment_status.rc == 2
          failed_when: deployment_status.rc == 1

      rescue:
        - name: Deployment failed, initiating rollback procedure
          ansible.builtin.debug:
            msg: "Deployment failed, checking for automatic rollback or initiating manual rollback"
        
        - name: Check current deployment state
          ansible.builtin.shell: |
            echo "=== Current Service State ==="
            docker service ls --filter "name={{ stack_name }}_"
            echo "=== Failed Tasks ==="
            docker service ps {{ stack_name }}_turbogate --no-trunc | grep -E "(Failed|Rejected)" || echo "No failed tasks found"
          register: failure_status
          
        - name: Display failure details
          ansible.builtin.debug:
            var: failure_status.stdout_lines
        
        - name: Force rollback if needed
          ansible.builtin.command: docker service rollback {{ stack_name }}_turbogate
          register: rollback_result
          failed_when: false
        
        - name: Wait for rollback to complete
          ansible.builtin.pause:
            seconds: 60
            
        - name: Fail deployment with details
          ansible.builtin.fail:
            msg: "Deployment failed. Rollback initiated. Check service logs: docker service logs {{ stack_name }}_turbogate"

    # Enhanced health verification with production certificates
    - name: Wait for services to fully stabilize
      ansible.builtin.pause:
        seconds: 30

    - name: Verify nginx container health directly
      ansible.builtin.shell: |
        NGINX_CONTAINER=$(docker ps -q -f name={{ stack_name }}_nginx --filter status=running | head -1)
        if [ ! -z "$NGINX_CONTAINER" ]; then
          docker exec $NGINX_CONTAINER curl -f http://localhost/lb-health
        else
          echo "No running nginx container found"
          exit 1
        fi
      register: nginx_internal_health
      retries: 5
      delay: 10
      until: nginx_internal_health.rc == 0
      failed_when: false

    - name: Verify service health via domain (HTTPS with production certs)
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/health"
        method: GET
        status_code: 200
        timeout: 15
        validate_certs: true
      register: domain_health_check
      retries: 10
      delay: 15
      until: domain_health_check.status == 200
      failed_when: false

    - name: Verify gateway endpoint via domain
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/gateway/health"
        method: GET
        status_code: 200
        timeout: 15
        validate_certs: true
      register: gateway_health_check
      retries: 5
      delay: 10
      until: gateway_health_check.status == 200
      failed_when: false

    - name: Verify load balancer health endpoint
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/lb-health"
        method: GET
        status_code: 200
        timeout: 10
        validate_certs: true
      register: lb_health_check
      retries: 3
      delay: 5
      until: lb_health_check.status == 200
      failed_when: false

    # Cleanup old versioned secrets after successful deployment
    - name: List all secrets for cleanup
      ansible.builtin.command: docker secret ls --format '{{ "{{" }}.Name{{ "}}" }}'
      register: all_secrets_post_deploy
      changed_when: false
      when: 
        - domain_health_check.status == 200
        - gateway_health_check.status == 200

    - name: Clean up old versioned secrets (keep only current version)
      ansible.builtin.command: docker secret rm {{ item }}
      loop: "{{ all_secrets_post_deploy.stdout_lines }}"
      when:
        - all_secrets_post_deploy is defined
        - item is regex('^(turbogate_secret_key|redis_password)_v[0-9]+

    # Post-deployment verification and reporting
    - name: Get comprehensive service status
      ansible.builtin.shell: |
        echo "=== Service Overview ==="
        docker service ls --filter "name={{ stack_name }}_"
        echo ""
        echo "=== TurboGate Service Tasks ==="
        docker service ps {{ stack_name }}_turbogate --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== NGINX Service Tasks ==="
        docker service ps {{ stack_name }}_nginx --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== Redis Service Tasks ==="
        docker service ps {{ stack_name }}_redis --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== Resource Usage ==="
        docker stats --no-stream --format "table {{ "{{" }}.Container{{ "}}" }}\t{{ "{{" }}.CPUPerc{{ "}}" }}\t{{ "{{" }}.MemUsage{{ "}}" }}" || echo "Stats not available"
      register: detailed_status
      changed_when: false
    
    - name: Display detailed service status
      ansible.builtin.debug:
        var: detailed_status.stdout_lines

    - name: Final deployment verification
      ansible.builtin.assert:
        that:
          - deployment_status.rc in [0, 2]
          - domain_health_check.status == 200
          - gateway_health_check.status == 200
          - nginx_internal_health.rc == 0
        fail_msg: "Deployment verification failed. Health checks: nginx_internal={{ nginx_internal_health.rc | default('failed') }}, domain={{ domain_health_check.status | default('failed') }}, gateway={{ gateway_health_check.status | default('failed') }}"
        success_msg: "Zero-downtime deployment completed successfully with production SSL certificates!"

    - name: Deployment summary
      ansible.builtin.debug:
        msg:
          - "=== DEPLOYMENT COMPLETED ==="
          - "Stack: {{ stack_name }}"
          - "Image: {{ docker_registry | default('docker.io') }}/{{ image_name | default('fwande/turbogate') }}:{{ image_tag }}"
          - "Domain: {{ domain_name }}"
          - "SSL Status: Production certificates (trusted)"
          - "Health Status - Domain: {{ domain_health_check.status | default('N/A') }}, Gateway: {{ gateway_health_check.status | default('N/A') }}"
          - "NGINX Internal: {{ 'OK' if nginx_internal_health.rc == 0 else 'Failed' }}"
          - "Monitor logs: docker service logs {{ stack_name }}_turbogate --follow"
          - "Service status: docker service ls --filter name={{ stack_name }}_")
        - item != 'turbogate_secret_key_v' + secret_version
        - item != 'redis_password_v' + secret_version
      failed_when: false
      ignore_errors: yes

    - name: List all configs for cleanup
      ansible.builtin.command: docker config ls --format '{{ "{{" }}.Name{{ "}}" }}'
      register: all_configs_post_deploy
      changed_when: false
      when: 
        - domain_health_check.status == 200
        - gateway_health_check.status == 200

    - name: Clean up old versioned nginx configs (keep only current version)
      ansible.builtin.command: docker config rm {{ item }}
      loop: "{{ all_configs_post_deploy.stdout_lines }}"
      when:
        - all_configs_post_deploy is defined
        - item is regex('^nginx_config_v[0-9]+

    # Post-deployment verification and reporting
    - name: Get comprehensive service status
      ansible.builtin.shell: |
        echo "=== Service Overview ==="
        docker service ls --filter "name={{ stack_name }}_"
        echo ""
        echo "=== TurboGate Service Tasks ==="
        docker service ps {{ stack_name }}_turbogate --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== NGINX Service Tasks ==="
        docker service ps {{ stack_name }}_nginx --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== Redis Service Tasks ==="
        docker service ps {{ stack_name }}_redis --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== Resource Usage ==="
        docker stats --no-stream --format "table {{ "{{" }}.Container{{ "}}" }}\t{{ "{{" }}.CPUPerc{{ "}}" }}\t{{ "{{" }}.MemUsage{{ "}}" }}" || echo "Stats not available"
      register: detailed_status
      changed_when: false
    
    - name: Display detailed service status
      ansible.builtin.debug:
        var: detailed_status.stdout_lines

    - name: Final deployment verification
      ansible.builtin.assert:
        that:
          - deployment_status.rc in [0, 2]
          - domain_health_check.status == 200
          - gateway_health_check.status == 200
          - nginx_internal_health.rc == 0
        fail_msg: "Deployment verification failed. Health checks: nginx_internal={{ nginx_internal_health.rc | default('failed') }}, domain={{ domain_health_check.status | default('failed') }}, gateway={{ gateway_health_check.status | default('failed') }}"
        success_msg: "Zero-downtime deployment completed successfully with production SSL certificates!"

    - name: Deployment summary
      ansible.builtin.debug:
        msg:
          - "=== DEPLOYMENT COMPLETED ==="
          - "Stack: {{ stack_name }}"
          - "Image: {{ docker_registry | default('docker.io') }}/{{ image_name | default('fwande/turbogate') }}:{{ image_tag }}"
          - "Domain: {{ domain_name }}"
          - "SSL Status: Production certificates (trusted)"
          - "Health Status - Domain: {{ domain_health_check.status | default('N/A') }}, Gateway: {{ gateway_health_check.status | default('N/A') }}"
          - "NGINX Internal: {{ 'OK' if nginx_internal_health.rc == 0 else 'Failed' }}"
          - "Monitor logs: docker service logs {{ stack_name }}_turbogate --follow"
          - "Service status: docker service ls --filter name={{ stack_name }}_")
        - item != 'nginx_config_v' + secret_version
      failed_when: false
      ignore_errors: yes

    # Post-deployment verification and reporting
    - name: Get comprehensive service status
      ansible.builtin.shell: |
        echo "=== Service Overview ==="
        docker service ls --filter "name={{ stack_name }}_"
        echo ""
        echo "=== TurboGate Service Tasks ==="
        docker service ps {{ stack_name }}_turbogate --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== NGINX Service Tasks ==="
        docker service ps {{ stack_name }}_nginx --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== Redis Service Tasks ==="
        docker service ps {{ stack_name }}_redis --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== Resource Usage ==="
        docker stats --no-stream --format "table {{ "{{" }}.Container{{ "}}" }}\t{{ "{{" }}.CPUPerc{{ "}}" }}\t{{ "{{" }}.MemUsage{{ "}}" }}" || echo "Stats not available"
      register: detailed_status
      changed_when: false
    
    - name: Display detailed service status
      ansible.builtin.debug:
        var: detailed_status.stdout_lines

    - name: Final deployment verification
      ansible.builtin.assert:
        that:
          - deployment_status.rc in [0, 2]
          - domain_health_check.status == 200
          - gateway_health_check.status == 200
          - nginx_internal_health.rc == 0
        fail_msg: "Deployment verification failed. Health checks: nginx_internal={{ nginx_internal_health.rc | default('failed') }}, domain={{ domain_health_check.status | default('failed') }}, gateway={{ gateway_health_check.status | default('failed') }}"
        success_msg: "Zero-downtime deployment completed successfully with production SSL certificates!"

    - name: Deployment summary
      ansible.builtin.debug:
        msg:
          - "=== DEPLOYMENT COMPLETED ==="
          - "Stack: {{ stack_name }}"
          - "Image: {{ docker_registry | default('docker.io') }}/{{ image_name | default('fwande/turbogate') }}:{{ image_tag }}"
          - "Domain: {{ domain_name }}"
          - "SSL Status: Production certificates (trusted)"
          - "Health Status - Domain: {{ domain_health_check.status | default('N/A') }}, Gateway: {{ gateway_health_check.status | default('N/A') }}"
          - "NGINX Internal: {{ 'OK' if nginx_internal_health.rc == 0 else 'Failed' }}"
          - "Monitor logs: docker service logs {{ stack_name }}_turbogate --follow"
          - "Service status: docker service ls --filter name={{ stack_name }}_"