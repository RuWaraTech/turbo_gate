---
- name: Deploy TurboGate Application with Zero Downtime
  hosts: swarm_managers
  become: yes
  
  vars:
    stack_name: turbogate
    compose_file: /opt/turbogate/docker-compose.yml
    health_check_timeout: 120
    deployment_timeout: 600
    ssh_timeout: 300

  tasks:
    - name: Validate required variables
      ansible.builtin.assert:
        that:
          - secret_key is defined
          - redis_password is defined
          - domain_name is defined
          - image_tag is defined
        fail_msg: "Required variables (secret_key, redis_password, domain_name, image_tag) must be defined"

    - name: Create application directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: '0755'
      loop:
        - /opt/turbogate
        - /var/log/turbogate
        - /var/lib/turbogate/redis
        - /var/log/turbogate/nginx
        - /var/cache/nginx
        
    - name: Set correct ownership for NGINX cache directory
      ansible.builtin.file:
        path: /var/cache/nginx
        state: directory
        owner: 101
        group: 101
        mode: '0755'
        recurse: yes

    # Pre-deployment health check with proper domain
    - name: Check current deployment health
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/gateway/health"
        method: GET
        status_code: [200, 404, 502, 503]
        timeout: 10
        validate_certs: true
      register: pre_deploy_health
      failed_when: false
      changed_when: false

    - name: Display pre-deployment status
      ansible.builtin.debug:
        msg: "Current deployment status: {{ pre_deploy_health.status | default('Unknown') }}"

    # Improved secrets management
    - name: Check existing secrets
      ansible.builtin.command: docker secret ls --format '{{ "{{" }}.Name{{ "}}" }}'
      register: existing_secrets
      changed_when: false
      failed_when: false

    - name: Remove existing secrets if they exist
      ansible.builtin.command: docker secret rm {{ item }}
      loop:
        - turbogate_secret_key
        - redis_password
      when: item in existing_secrets.stdout_lines
      failed_when: false

    - name: Wait for secret removal
      ansible.builtin.pause:
        seconds: 5
      when: existing_secrets.stdout_lines | length > 0

    - name: Create Docker secrets
      ansible.builtin.shell: |
        echo -n "{{ item.value }}" | docker secret create {{ item.name }} -
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true
      register: secret_creation
      failed_when: secret_creation.rc != 0

    # Improved NGINX config management
    - name: Create NGINX configuration content
      ansible.builtin.template:
        src: nginx.conf.j2 
        dest: /tmp/nginx.conf
        owner: root
        group: root
        mode: '0644'

    - name: Remove existing NGINX config if it exists
      ansible.builtin.command: docker config rm nginx_config
      failed_when: false

    - name: Wait for config removal
      ansible.builtin.pause:
        seconds: 3

    - name: Create new NGINX config
      ansible.builtin.command: docker config create nginx_config /tmp/nginx.conf
      register: nginx_config_creation
      failed_when: nginx_config_creation.rc != 0

    - name: Clean up temporary nginx config file
      ansible.builtin.file:
        path: /tmp/nginx.conf
        state: absent
    
    - name: Verify overlay network exists
      community.docker.docker_network:
        name: turbogate_network
        driver: overlay
        attachable: yes
        state: present
    
    - name: Create Docker Compose file
      ansible.builtin.template:
        src: docker-compose.yml.j2
        dest: "{{ compose_file }}"
        owner: root
        group: root
        mode: '0644'
        backup: yes
    
    # Docker Swarm will automatically pull images during deployment
    # No pre-pulling needed - this prevents SSH timeouts and unnecessary complexity

    # Check current stack state
    - name: Check current stack status
      ansible.builtin.command: docker stack ls --format '{{ "{{" }}.Name{{ "}}" }}'
      register: existing_stacks
      changed_when: false

    - name: Get current service info if stack exists
      ansible.builtin.command: |
        docker service inspect {{ stack_name }}_turbogate --format '{{ "{{" }}.Spec.TaskTemplate.ContainerSpec.Image{{ "}}" }}'
      register: current_image
      when: stack_name in existing_stacks.stdout_lines
      failed_when: false
      changed_when: false

    - name: Display current vs new image
      ansible.builtin.debug:
        msg:
          - "Current image: {{ current_image.stdout | default('None') }}"
          - "New image: {{ docker_registry | default('docker.io') }}/{{ image_name | default('fwande/turbogate') }}:{{ image_tag }}"
      when: current_image is defined

    # Zero-downtime deployment strategy with better error handling
    - name: Deploy or update Docker stack with zero downtime
      block:
        - name: Deploy Docker stack
          community.docker.docker_stack:
            name: "{{ stack_name }}"
            compose:
              - "{{ compose_file }}"
            state: present
            prune: yes
          register: stack_deploy
          timeout: "{{ deployment_timeout }}"

        - name: Wait for initial deployment to stabilize
          ansible.builtin.pause:
            seconds: 45

        - name: Monitor deployment progress with detailed logging
          ansible.builtin.shell: |
            echo "=== Checking Service Replicas ==="
            TURBOGATE_DESIRED=$(docker service inspect {{ stack_name }}_turbogate --format '{{ "{{" }}.Spec.Mode.Replicated.Replicas{{ "}}" }}' 2>/dev/null || echo "0")
            REDIS_DESIRED=$(docker service inspect {{ stack_name }}_redis --format '{{ "{{" }}.Spec.Mode.Replicated.Replicas{{ "}}" }}' 2>/dev/null || echo "0")
            NGINX_DESIRED=$(docker service inspect {{ stack_name }}_nginx --format '{{ "{{" }}.Spec.Mode.Replicated.Replicas{{ "}}" }}' 2>/dev/null || echo "0")
            
            echo "Desired replicas - TurboGate: $TURBOGATE_DESIRED, Redis: $REDIS_DESIRED, NGINX: $NGINX_DESIRED"
            
            # Count running tasks
            TURBOGATE_RUNNING=$(docker service ps {{ stack_name }}_turbogate --filter "desired-state=running" --format "{{ "{{" }}.CurrentState{{ "}}" }}" 2>/dev/null | grep -c "Running" || echo "0")
            REDIS_RUNNING=$(docker service ps {{ stack_name }}_redis --filter "desired-state=running" --format "{{ "{{" }}.CurrentState{{ "}}" }}" 2>/dev/null | grep -c "Running" || echo "0")
            NGINX_RUNNING=$(docker service ps {{ stack_name }}_nginx --filter "desired-state=running" --format "{{ "{{" }}.CurrentState{{ "}}" }}" 2>/dev/null | grep -c "Running" || echo "0")
            
            echo "Running replicas - TurboGate: $TURBOGATE_RUNNING/$TURBOGATE_DESIRED, Redis: $REDIS_RUNNING/$REDIS_DESIRED, NGINX: $NGINX_RUNNING/$NGINX_DESIRED"
            
            # Check for any failed tasks
            FAILED_TASKS=$(docker service ps {{ stack_name }}_turbogate --filter "desired-state=running" --format "{{ "{{" }}.CurrentState{{ "}}" }}" 2>/dev/null | grep -c "Failed" || echo "0")
            if [ "$FAILED_TASKS" -gt 0 ]; then
              echo "WARNING: $FAILED_TASKS failed tasks detected"
              docker service ps {{ stack_name }}_turbogate --filter "desired-state=running" --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.Error{{ "}}" }}"
            fi
            
            # Return success if all services have at least minimum running replicas
            if [ "$TURBOGATE_RUNNING" -ge "1" ] && [ "$REDIS_RUNNING" -ge "1" ] && [ "$NGINX_RUNNING" -ge "1" ]; then
              if [ "$TURBOGATE_RUNNING" -ge "$TURBOGATE_DESIRED" ] && [ "$REDIS_RUNNING" -ge "$REDIS_DESIRED" ] && [ "$NGINX_RUNNING" -ge "$NGINX_DESIRED" ]; then
                echo "SUCCESS: All services at desired replica count"
                exit 0
              else
                echo "PARTIAL: Services running but not at full capacity"
                exit 2
              fi
            else
              echo "FAILED: Critical services not running"
              exit 1
            fi
          register: deployment_status
          retries: 5
          delay: 1
          until: deployment_status.rc == 0 or deployment_status.rc == 2
          failed_when: deployment_status.rc == 1

      rescue:
        - name: Deployment failed, initiating rollback procedure
          ansible.builtin.debug:
            msg: "Deployment failed, checking for automatic rollback or initiating manual rollback"
        
        - name: Check current deployment state
          ansible.builtin.shell: |
            echo "=== Current Service State ==="
            docker service ls --filter "name={{ stack_name }}_"
            echo "=== Failed Tasks ==="
            docker service ps {{ stack_name }}_turbogate --no-trunc | grep -E "(Failed|Rejected)" || echo "No failed tasks found"
          register: failure_status
          
        - name: Display failure details
          ansible.builtin.debug:
            var: failure_status.stdout_lines
        
        - name: Force rollback if needed
          ansible.builtin.command: docker service rollback {{ stack_name }}_turbogate
          register: rollback_result
          failed_when: false
        
        - name: Wait for rollback to complete
          ansible.builtin.pause:
            seconds: 60
            
        - name: Fail deployment with details
          ansible.builtin.fail:
            msg: "Deployment failed. Rollback initiated. Check service logs: docker service logs {{ stack_name }}_turbogate"

    # Enhanced health verification with production certificates
    - name: Wait for services to fully stabilize
      ansible.builtin.pause:
        seconds: 30

    - name: Verify nginx container health directly
      ansible.builtin.shell: |
        NGINX_CONTAINER=$(docker ps -q -f name={{ stack_name }}_nginx --filter status=running | head -1)
        if [ ! -z "$NGINX_CONTAINER" ]; then
          docker exec $NGINX_CONTAINER curl -f http://localhost/lb-health
        else
          echo "No running nginx container found"
          exit 1
        fi
      register: nginx_internal_health
      retries: 5
      delay: 10
      until: nginx_internal_health.rc == 0
      failed_when: false

    - name: Verify service health via domain (HTTPS with production certs)
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/health"
        method: GET
        status_code: 200
        timeout: 15
        validate_certs: true
      register: domain_health_check
      retries: 10
      delay: 15
      until: domain_health_check.status == 200
      failed_when: false

    - name: Verify gateway endpoint via domain
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/gateway/health"
        method: GET
        status_code: 200
        timeout: 15
        validate_certs: true
      register: gateway_health_check
      retries: 5
      delay: 10
      until: gateway_health_check.status == 200
      failed_when: false

    - name: Verify load balancer health endpoint
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/lb-health"
        method: GET
        status_code: 200
        timeout: 10
        validate_certs: true
      register: lb_health_check
      retries: 3
      delay: 5
      until: lb_health_check.status == 200
      failed_when: false

    # Post-deployment verification and reporting
    - name: Get comprehensive service status
      ansible.builtin.shell: |
        echo "=== Service Overview ==="
        docker service ls --filter "name={{ stack_name }}_"
        echo ""
        echo "=== TurboGate Service Tasks ==="
        docker service ps {{ stack_name }}_turbogate --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== NGINX Service Tasks ==="
        docker service ps {{ stack_name }}_nginx --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== Redis Service Tasks ==="
        docker service ps {{ stack_name }}_redis --no-trunc --format "table {{ "{{" }}.Name{{ "}}" }}\t{{ "{{" }}.Node{{ "}}" }}\t{{ "{{" }}.CurrentState{{ "}}" }}\t{{ "{{" }}.DesiredState{{ "}}" }}"
        echo ""
        echo "=== Resource Usage ==="
        docker stats --no-stream --format "table {{ "{{" }}.Container{{ "}}" }}\t{{ "{{" }}.CPUPerc{{ "}}" }}\t{{ "{{" }}.MemUsage{{ "}}" }}" || echo "Stats not available"
      register: detailed_status
      changed_when: false
    
    - name: Display detailed service status
      ansible.builtin.debug:
        var: detailed_status.stdout_lines

    - name: Final deployment verification
      ansible.builtin.assert:
        that:
          - deployment_status.rc in [0, 2]
          - domain_health_check.status == 200
          - gateway_health_check.status == 200
          - nginx_internal_health.rc == 0
        fail_msg: "Deployment verification failed. Health checks: nginx_internal={{ nginx_internal_health.rc | default('failed') }}, domain={{ domain_health_check.status | default('failed') }}, gateway={{ gateway_health_check.status | default('failed') }}"
        success_msg: "Zero-downtime deployment completed successfully with production SSL certificates!"

    - name: Deployment summary
      ansible.builtin.debug:
        msg:
          - "=== DEPLOYMENT COMPLETED ==="
          - "Stack: {{ stack_name }}"
          - "Image: {{ docker_registry | default('docker.io') }}/{{ image_name | default('fwande/turbogate') }}:{{ image_tag }}"
          - "Domain: {{ domain_name }}"
          - "SSL Status: Production certificates (trusted)"
          - "Health Status - Domain: {{ domain_health_check.status | default('N/A') }}, Gateway: {{ gateway_health_check.status | default('N/A') }}"
          - "NGINX Internal: {{ 'OK' if nginx_internal_health.rc == 0 else 'Failed' }}"
          - "Monitor logs: docker service logs {{ stack_name }}_turbogate --follow"
          - "Service status: docker service ls --filter name={{ stack_name }}_"