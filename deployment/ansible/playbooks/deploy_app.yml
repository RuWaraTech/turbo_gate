---
- name: Deploy TurboGate with Load Balancer SSL Termination
  hosts: swarm_managers
  become: yes
  
  vars:
    stack_name: turbogate
    compose_file: /opt/turbogate/docker-compose-waf.yml
    
  tasks:
    - name: Validate required variables
      ansible.builtin.assert:
        that:
          - secret_key is defined
          - redis_password is defined
          - domain_name is defined
          - image_tag is defined
          - ssl_certificate_type == "managed"
        fail_msg: "Required variables must be defined and ssl_certificate_type must be 'managed' for LB SSL termination"

    - name: Verify Load Balancer is reachable
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/lb-health"
        method: GET
        timeout: 10
        validate_certs: yes
        status_code: [200, 502, 503]
      register: lb_ssl_check
      retries: 10
      delay: 30
      until: lb_ssl_check.status != -1

    - name: Create required directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: '0755'
      loop:
        - /opt/turbogate
        - /var/log/turbogate
        - /var/lib/turbogate/redis
        - /var/log/nginx/waf
        - /var/cache/nginx

    # ===================================================================
    # BEGIN: ZERO-DOWNTIME SECRET & CONFIG MANAGEMENT
    # ===================================================================

    - name: Get current timestamp for versioning
      ansible.builtin.set_fact:
        resource_version: "{{ ansible_date_time.epoch }}"

    # Check if stack exists FIRST
    - name: Check if stack exists
      ansible.builtin.shell:
        cmd: "docker stack ls --format '{%raw%}{{.Name}}{%endraw%}' | grep -q '^{{ stack_name }}

    # --- SECRET MANAGEMENT ---
    - name: Create new versioned Docker secrets
      ansible.builtin.shell:
        cmd: "echo -n '{{ item.value }}' | docker secret create {{ item.name }}_v{{ resource_version }} -"
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true

    # Only try to create unversioned secrets if stack doesn't exist
    - name: Create unversioned secret aliases (new deployment only)
      ansible.builtin.shell:
        cmd: "echo -n '{{ item.value }}' | docker secret create {{ item.name }} -"
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true
      when: stack_exists.rc != 0
      ignore_errors: yes
      
    # --- CONFIG MANAGEMENT ---
    - name: Create ModSecurity configuration content in a temporary file
      ansible.builtin.copy:
        dest: "/tmp/modsecurity_{{ resource_version }}.conf"
        content: |
          SecRuleEngine {{ waf_rule_engine | default('On') }}
          SecRequestBodyAccess On
          SecResponseBodyAccess On
          SecResponseBodyMimeType text/plain text/html text/xml application/json
          SecResponseBodyLimit 524288
          SecResponseBodyLimitAction ProcessPartial
          SecAuditEngine {{ waf_audit_engine | default('RelevantOnly') }}
          SecAuditLogRelevantStatus "^(?:5|4(?!04))"
          SecAuditLogParts ABDEFHIJZ
          SecAuditLogType Serial
          SecAuditLog /var/log/nginx/modsec_audit.log

    - name: Create ModSecurity rules content in a temporary file
      ansible.builtin.copy:
        dest: "/tmp/modsecurity_rules_{{ resource_version }}.conf"
        content: |
          Include /etc/nginx/modsecurity/modsecurity.conf
          Include /usr/local/owasp-modsecurity-crs/crs-setup.conf
          Include /usr/local/owasp-modsecurity-crs/rules/*.conf
          SecRule REQUEST_URI "@beginsWith /health" "id:1000,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecRule REQUEST_URI "@beginsWith /waf-health" "id:1001,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecRule REQUEST_URI "@beginsWith /lb-health" "id:1002,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecAction "id:900000,phase:1,nolog,pass,t:none,setvar:tx.paranoia_level={{ waf_paranoia_level | default(2) }}"
          SecAction "id:900001,phase:1,nolog,pass,t:none,setvar:tx.inbound_anomaly_score_threshold={{ waf_anomaly_inbound | default(10) }},setvar:tx.outbound_anomaly_score_threshold={{ waf_anomaly_outbound | default(8) }}"

    - name: Create backend NGINX config content from template
      ansible.builtin.template:
        src: nginx-waf.conf.j2
        dest: "/tmp/nginx-waf_{{ resource_version }}.conf"
        mode: '0644'

    - name: Create versioned configs
      ansible.builtin.command: "docker config create {{ item.name }}_v{{ resource_version }} {{ item.path }}"
      loop:
        - { name: "modsecurity_config", path: "/tmp/modsecurity_{{ resource_version }}.conf" }
        - { name: "modsecurity_rules", path: "/tmp/modsecurity_rules_{{ resource_version }}.conf" }
        - { name: "nginx_backend_config", path: "/tmp/nginx-waf_{{ resource_version }}.conf" }

    # Only create unversioned configs for new deployments
    - name: Create unversioned config aliases (new deployment only)
      ansible.builtin.command: "docker config create {{ item.name }} {{ item.path }}"
      loop:
        - { name: "modsecurity_config", path: "/tmp/modsecurity_{{ resource_version }}.conf" }
        - { name: "modsecurity_rules", path: "/tmp/modsecurity_rules_{{ resource_version }}.conf" }
        - { name: "nginx_backend_config", path: "/tmp/nginx-waf_{{ resource_version }}.conf" }
      when: stack_exists.rc != 0
      ignore_errors: yes
    
    - name: Clean up temporary config files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - "/tmp/modsecurity_{{ resource_version }}.conf"
        - "/tmp/modsecurity_rules_{{ resource_version }}.conf"
        - "/tmp/nginx-waf_{{ resource_version }}.conf"

    # ===================================================================
    # END: ZERO-DOWNTIME SECRET & CONFIG MANAGEMENT
    # ===================================================================

    - name: Create overlay networks if not exist
      community.docker.docker_network:
        name: "{{ item }}"
        driver: overlay
        attachable: yes
      loop:
        - turbogate_frontend
        - turbogate_backend
        - turbogate_database

    - name: Create Docker Compose file from template
      ansible.builtin.template:
        src: docker-compose-waf.yml.j2
        dest: "{{ compose_file }}"
        mode: '0644'
        backup: yes

    # Proper deployment strategy
    - name: Deploy Docker stack (new deployment)
      community.docker.docker_stack:
        name: "{{ stack_name }}"
        compose:
          - "{{ compose_file }}"
        state: present
        prune: no  # Don't prune on updates
      register: stack_deploy
      when: stack_exists.rc != 0

    # Rolling update for existing deployment
    - name: Perform rolling update for existing stack
      block:
        - name: Update turbogate service with new secrets
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --secret-rm turbogate_secret_key \
                --secret-add source=turbogate_secret_key_v{{ resource_version }},target=SECRET_KEY \
                --secret-rm redis_password \
                --secret-add source=redis_password_v{{ resource_version }},target=redis_password \
                --update-parallelism 1 \
                --update-delay 30s \
                --update-order start-first \
                {{ stack_name }}_turbogate
          register: turbogate_update

        - name: Update redis service with new password
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --secret-rm redis_password \
                --secret-add source=redis_password_v{{ resource_version }},target=redis_password \
                --update-parallelism 1 \
                --update-delay 30s \
                {{ stack_name }}_redis
          register: redis_update

        - name: Update nginx-waf service with new configs
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --config-rm modsecurity_config \
                --config-add source=modsecurity_config_v{{ resource_version }},target=/etc/nginx/modsecurity/modsecurity.conf \
                --config-rm modsecurity_rules \
                --config-add source=modsecurity_rules_v{{ resource_version }},target=/etc/nginx/modsecurity/main.conf \
                --config-rm nginx_backend_config \
                --config-add source=nginx_backend_config_v{{ resource_version }},target=/etc/nginx/nginx.conf \
                --update-parallelism 1 \
                --update-delay 30s \
                {{ stack_name }}_nginx-waf
          register: nginx_update

        - name: Set update status
          ansible.builtin.set_fact:
            stack_deploy:
              changed: true
              
      when: stack_exists.rc == 0

    - name: Wait for services to stabilize
      ansible.builtin.pause:
        seconds: 45

    - name: Verify application services are running
      ansible.builtin.shell:
        cmd: |
          for service in nginx-waf turbogate redis; do
            replicas=$(docker service ls --filter name={{ stack_name }}_$service --format '{{'{{'}}'.Replicas{{'}}'}}')
            if [ -z "$replicas" ]; then
              echo "ERROR: Service $service not found."
              exit 1
            fi
            running=$(echo $replicas | cut -d'/' -f1)
            desired=$(echo $replicas | cut -d'/' -f2)
            if [ "$running" != "$desired" ] || [ "$running" -lt "1" ]; then
              echo "ERROR: Service $service is not running correctly. Replicas: $replicas"
              docker service ps {{ stack_name }}_$service --no-trunc
              exit 1
            fi
            echo "✓ Service $service is running with replicas: $replicas"
          done
      register: service_check
      retries: 8
      delay: 15
      until: service_check.rc == 0

    - name: Final health check via Load Balancer
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/health"
        method: GET
        status_code: 200
        timeout: 15
        validate_certs: yes
      register: lb_https_health
      retries: 12
      delay: 15
      until: lb_https_health.status == 200

    - name: Clean up old versioned secrets and configs post-deployment
      ansible.builtin.shell:
        cmd: |
          # Clean up old secrets
          docker secret ls --format '{%raw%}{{.Name}}{%endraw%}' | grep -E '^(turbogate_secret_key|redis_password)_v[0-9]+

    - name: Display deployment summary
      ansible.builtin.debug:
        msg: |
          ✅ DEPLOYMENT COMPLETE ✅
          Stack: {{ stack_name }}
          Domain: https://{{ domain_name }}
          Access URL: https://{{ domain_name }}/health
          Resource Version: {{ resource_version }}
          Deployment Type: {{ 'New Deployment' if stack_exists.rc != 0 else 'Rolling Update' }}"
      register: stack_exists
      failed_when: false
      changed_when: false

    # --- SECRET MANAGEMENT ---
    - name: Create new versioned Docker secrets
      ansible.builtin.shell:
        cmd: "echo -n '{{ item.value }}' | docker secret create {{ item.name }}_v{{ resource_version }} -"
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true

    # Only try to create unversioned secrets if stack doesn't exist
    - name: Create unversioned secret aliases (new deployment only)
      ansible.builtin.shell:
        cmd: "echo -n '{{ item.value }}' | docker secret create {{ item.name }} -"
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true
      when: stack_exists.rc != 0
      ignore_errors: yes
      
    # --- CONFIG MANAGEMENT ---
    - name: Create ModSecurity configuration content in a temporary file
      ansible.builtin.copy:
        dest: "/tmp/modsecurity_{{ resource_version }}.conf"
        content: |
          SecRuleEngine {{ waf_rule_engine | default('On') }}
          SecRequestBodyAccess On
          SecResponseBodyAccess On
          SecResponseBodyMimeType text/plain text/html text/xml application/json
          SecResponseBodyLimit 524288
          SecResponseBodyLimitAction ProcessPartial
          SecAuditEngine {{ waf_audit_engine | default('RelevantOnly') }}
          SecAuditLogRelevantStatus "^(?:5|4(?!04))"
          SecAuditLogParts ABDEFHIJZ
          SecAuditLogType Serial
          SecAuditLog /var/log/nginx/modsec_audit.log

    - name: Create ModSecurity rules content in a temporary file
      ansible.builtin.copy:
        dest: "/tmp/modsecurity_rules_{{ resource_version }}.conf"
        content: |
          Include /etc/nginx/modsecurity/modsecurity.conf
          Include /usr/local/owasp-modsecurity-crs/crs-setup.conf
          Include /usr/local/owasp-modsecurity-crs/rules/*.conf
          SecRule REQUEST_URI "@beginsWith /health" "id:1000,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecRule REQUEST_URI "@beginsWith /waf-health" "id:1001,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecRule REQUEST_URI "@beginsWith /lb-health" "id:1002,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecAction "id:900000,phase:1,nolog,pass,t:none,setvar:tx.paranoia_level={{ waf_paranoia_level | default(2) }}"
          SecAction "id:900001,phase:1,nolog,pass,t:none,setvar:tx.inbound_anomaly_score_threshold={{ waf_anomaly_inbound | default(10) }},setvar:tx.outbound_anomaly_score_threshold={{ waf_anomaly_outbound | default(8) }}"

    - name: Create backend NGINX config content from template
      ansible.builtin.template:
        src: nginx-waf.conf.j2
        dest: "/tmp/nginx-waf_{{ resource_version }}.conf"
        mode: '0644'

    - name: Create versioned configs
      ansible.builtin.command: "docker config create {{ item.name }}_v{{ resource_version }} {{ item.path }}"
      loop:
        - { name: "modsecurity_config", path: "/tmp/modsecurity_{{ resource_version }}.conf" }
        - { name: "modsecurity_rules", path: "/tmp/modsecurity_rules_{{ resource_version }}.conf" }
        - { name: "nginx_backend_config", path: "/tmp/nginx-waf_{{ resource_version }}.conf" }

    # Only create unversioned configs for new deployments
    - name: Create unversioned config aliases (new deployment only)
      ansible.builtin.command: "docker config create {{ item.name }} {{ item.path }}"
      loop:
        - { name: "modsecurity_config", path: "/tmp/modsecurity_{{ resource_version }}.conf" }
        - { name: "modsecurity_rules", path: "/tmp/modsecurity_rules_{{ resource_version }}.conf" }
        - { name: "nginx_backend_config", path: "/tmp/nginx-waf_{{ resource_version }}.conf" }
      when: stack_exists.rc != 0
      ignore_errors: yes
    
    - name: Clean up temporary config files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - "/tmp/modsecurity_{{ resource_version }}.conf"
        - "/tmp/modsecurity_rules_{{ resource_version }}.conf"
        - "/tmp/nginx-waf_{{ resource_version }}.conf"

    # ===================================================================
    # END: ZERO-DOWNTIME SECRET & CONFIG MANAGEMENT
    # ===================================================================

    - name: Create overlay networks if not exist
      community.docker.docker_network:
        name: "{{ item }}"
        driver: overlay
        attachable: yes
      loop:
        - turbogate_frontend
        - turbogate_backend
        - turbogate_database

    - name: Create Docker Compose file from template
      ansible.builtin.template:
        src: docker-compose-waf.yml.j2
        dest: "{{ compose_file }}"
        mode: '0644'
        backup: yes

    # Proper deployment strategy
    - name: Deploy Docker stack (new deployment)
      community.docker.docker_stack:
        name: "{{ stack_name }}"
        compose:
          - "{{ compose_file }}"
        state: present
        prune: no  # Don't prune on updates
      register: stack_deploy
      when: stack_exists.rc != 0

    # Rolling update for existing deployment
    - name: Perform rolling update for existing stack
      block:
        - name: Update turbogate service with new secrets
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --secret-rm turbogate_secret_key \
                --secret-add source=turbogate_secret_key_v{{ resource_version }},target=SECRET_KEY \
                --secret-rm redis_password \
                --secret-add source=redis_password_v{{ resource_version }},target=redis_password \
                --update-parallelism 1 \
                --update-delay 30s \
                --update-order start-first \
                {{ stack_name }}_turbogate
          register: turbogate_update

        - name: Update redis service with new password
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --secret-rm redis_password \
                --secret-add source=redis_password_v{{ resource_version }},target=redis_password \
                --update-parallelism 1 \
                --update-delay 30s \
                {{ stack_name }}_redis
          register: redis_update

        - name: Update nginx-waf service with new configs
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --config-rm modsecurity_config \
                --config-add source=modsecurity_config_v{{ resource_version }},target=/etc/nginx/modsecurity/modsecurity.conf \
                --config-rm modsecurity_rules \
                --config-add source=modsecurity_rules_v{{ resource_version }},target=/etc/nginx/modsecurity/main.conf \
                --config-rm nginx_backend_config \
                --config-add source=nginx_backend_config_v{{ resource_version }},target=/etc/nginx/nginx.conf \
                --update-parallelism 1 \
                --update-delay 30s \
                {{ stack_name }}_nginx-waf
          register: nginx_update

        - name: Set update status
          ansible.builtin.set_fact:
            stack_deploy:
              changed: true
              
      when: stack_exists.rc == 0

    - name: Wait for services to stabilize
      ansible.builtin.pause:
        seconds: 45

    - name: Verify application services are running
      ansible.builtin.shell:
        cmd: |
          for service in nginx-waf turbogate redis; do
            replicas=$(docker service ls --filter name={{ stack_name }}_$service --format '{{.Replicas}}')
            if [ -z "$replicas" ]; then
              echo "ERROR: Service $service not found."
              exit 1
            fi
            running=$(echo $replicas | cut -d'/' -f1)
            desired=$(echo $replicas | cut -d'/' -f2)
            if [ "$running" != "$desired" ] || [ "$running" -lt "1" ]; then
              echo "ERROR: Service $service is not running correctly. Replicas: $replicas"
              docker service ps {{ stack_name }}_$service --no-trunc
              exit 1
            fi
            echo "✓ Service $service is running with replicas: $replicas"
          done
      register: service_check
      retries: 8
      delay: 15
      until: service_check.rc == 0

    - name: Final health check via Load Balancer
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/health"
        method: GET
        status_code: 200
        timeout: 15
        validate_certs: yes
      register: lb_https_health
      retries: 12
      delay: 15
      until: lb_https_health.status == 200

    - name: Clean up old versioned secrets and configs post-deployment
      ansible.builtin.shell:
        cmd: |
          # Clean up old secrets
          docker secret ls --format '{{.Name}}' | grep -E '^(turbogate_secret_key|redis_password)_v[0-9]+$' | grep -v "v{{ resource_version }}$" | xargs -r docker secret rm 2>/dev/null || true
          # Clean up old configs  
          docker config ls --format '{{.Name}}' | grep -E '^(modsecurity_config|modsecurity_rules|nginx_backend_config)_v[0-9]+$' | grep -v "v{{ resource_version }}$" | xargs -r docker config rm 2>/dev/null || true
      when: stack_deploy.changed
      ignore_errors: yes
      changed_when: false

    - name: Display deployment summary
      ansible.builtin.debug:
        msg: |
          ✅ DEPLOYMENT COMPLETE ✅
          Stack: {{ stack_name }}
          Domain: https://{{ domain_name }}
          Access URL: https://{{ domain_name }}/health
          Resource Version: {{ resource_version }}
          Deployment Type: {{ 'New Deployment' if stack_exists.rc != 0 else 'Rolling Update' }} | grep -v "v{{ resource_version }}$" | xargs -r docker secret rm 2>/dev/null || true
          # Clean up old configs  
          docker config ls --format '{%raw%}{{.Name}}{%endraw%}' | grep -E '^(modsecurity_config|modsecurity_rules|nginx_backend_config)_v[0-9]+

    - name: Display deployment summary
      ansible.builtin.debug:
        msg: |
          ✅ DEPLOYMENT COMPLETE ✅
          Stack: {{ stack_name }}
          Domain: https://{{ domain_name }}
          Access URL: https://{{ domain_name }}/health
          Resource Version: {{ resource_version }}
          Deployment Type: {{ 'New Deployment' if stack_exists.rc != 0 else 'Rolling Update' }}"
      register: stack_exists
      failed_when: false
      changed_when: false

    # --- SECRET MANAGEMENT ---
    - name: Create new versioned Docker secrets
      ansible.builtin.shell:
        cmd: "echo -n '{{ item.value }}' | docker secret create {{ item.name }}_v{{ resource_version }} -"
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true

    # Only try to create unversioned secrets if stack doesn't exist
    - name: Create unversioned secret aliases (new deployment only)
      ansible.builtin.shell:
        cmd: "echo -n '{{ item.value }}' | docker secret create {{ item.name }} -"
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true
      when: stack_exists.rc != 0
      ignore_errors: yes
      
    # --- CONFIG MANAGEMENT ---
    - name: Create ModSecurity configuration content in a temporary file
      ansible.builtin.copy:
        dest: "/tmp/modsecurity_{{ resource_version }}.conf"
        content: |
          SecRuleEngine {{ waf_rule_engine | default('On') }}
          SecRequestBodyAccess On
          SecResponseBodyAccess On
          SecResponseBodyMimeType text/plain text/html text/xml application/json
          SecResponseBodyLimit 524288
          SecResponseBodyLimitAction ProcessPartial
          SecAuditEngine {{ waf_audit_engine | default('RelevantOnly') }}
          SecAuditLogRelevantStatus "^(?:5|4(?!04))"
          SecAuditLogParts ABDEFHIJZ
          SecAuditLogType Serial
          SecAuditLog /var/log/nginx/modsec_audit.log

    - name: Create ModSecurity rules content in a temporary file
      ansible.builtin.copy:
        dest: "/tmp/modsecurity_rules_{{ resource_version }}.conf"
        content: |
          Include /etc/nginx/modsecurity/modsecurity.conf
          Include /usr/local/owasp-modsecurity-crs/crs-setup.conf
          Include /usr/local/owasp-modsecurity-crs/rules/*.conf
          SecRule REQUEST_URI "@beginsWith /health" "id:1000,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecRule REQUEST_URI "@beginsWith /waf-health" "id:1001,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecRule REQUEST_URI "@beginsWith /lb-health" "id:1002,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecAction "id:900000,phase:1,nolog,pass,t:none,setvar:tx.paranoia_level={{ waf_paranoia_level | default(2) }}"
          SecAction "id:900001,phase:1,nolog,pass,t:none,setvar:tx.inbound_anomaly_score_threshold={{ waf_anomaly_inbound | default(10) }},setvar:tx.outbound_anomaly_score_threshold={{ waf_anomaly_outbound | default(8) }}"

    - name: Create backend NGINX config content from template
      ansible.builtin.template:
        src: nginx-waf.conf.j2
        dest: "/tmp/nginx-waf_{{ resource_version }}.conf"
        mode: '0644'

    - name: Create versioned configs
      ansible.builtin.command: "docker config create {{ item.name }}_v{{ resource_version }} {{ item.path }}"
      loop:
        - { name: "modsecurity_config", path: "/tmp/modsecurity_{{ resource_version }}.conf" }
        - { name: "modsecurity_rules", path: "/tmp/modsecurity_rules_{{ resource_version }}.conf" }
        - { name: "nginx_backend_config", path: "/tmp/nginx-waf_{{ resource_version }}.conf" }

    # Only create unversioned configs for new deployments
    - name: Create unversioned config aliases (new deployment only)
      ansible.builtin.command: "docker config create {{ item.name }} {{ item.path }}"
      loop:
        - { name: "modsecurity_config", path: "/tmp/modsecurity_{{ resource_version }}.conf" }
        - { name: "modsecurity_rules", path: "/tmp/modsecurity_rules_{{ resource_version }}.conf" }
        - { name: "nginx_backend_config", path: "/tmp/nginx-waf_{{ resource_version }}.conf" }
      when: stack_exists.rc != 0
      ignore_errors: yes
    
    - name: Clean up temporary config files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - "/tmp/modsecurity_{{ resource_version }}.conf"
        - "/tmp/modsecurity_rules_{{ resource_version }}.conf"
        - "/tmp/nginx-waf_{{ resource_version }}.conf"

    # ===================================================================
    # END: ZERO-DOWNTIME SECRET & CONFIG MANAGEMENT
    # ===================================================================

    - name: Create overlay networks if not exist
      community.docker.docker_network:
        name: "{{ item }}"
        driver: overlay
        attachable: yes
      loop:
        - turbogate_frontend
        - turbogate_backend
        - turbogate_database

    - name: Create Docker Compose file from template
      ansible.builtin.template:
        src: docker-compose-waf.yml.j2
        dest: "{{ compose_file }}"
        mode: '0644'
        backup: yes

    # Proper deployment strategy
    - name: Deploy Docker stack (new deployment)
      community.docker.docker_stack:
        name: "{{ stack_name }}"
        compose:
          - "{{ compose_file }}"
        state: present
        prune: no  # Don't prune on updates
      register: stack_deploy
      when: stack_exists.rc != 0

    # Rolling update for existing deployment
    - name: Perform rolling update for existing stack
      block:
        - name: Update turbogate service with new secrets
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --secret-rm turbogate_secret_key \
                --secret-add source=turbogate_secret_key_v{{ resource_version }},target=SECRET_KEY \
                --secret-rm redis_password \
                --secret-add source=redis_password_v{{ resource_version }},target=redis_password \
                --update-parallelism 1 \
                --update-delay 30s \
                --update-order start-first \
                {{ stack_name }}_turbogate
          register: turbogate_update

        - name: Update redis service with new password
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --secret-rm redis_password \
                --secret-add source=redis_password_v{{ resource_version }},target=redis_password \
                --update-parallelism 1 \
                --update-delay 30s \
                {{ stack_name }}_redis
          register: redis_update

        - name: Update nginx-waf service with new configs
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --config-rm modsecurity_config \
                --config-add source=modsecurity_config_v{{ resource_version }},target=/etc/nginx/modsecurity/modsecurity.conf \
                --config-rm modsecurity_rules \
                --config-add source=modsecurity_rules_v{{ resource_version }},target=/etc/nginx/modsecurity/main.conf \
                --config-rm nginx_backend_config \
                --config-add source=nginx_backend_config_v{{ resource_version }},target=/etc/nginx/nginx.conf \
                --update-parallelism 1 \
                --update-delay 30s \
                {{ stack_name }}_nginx-waf
          register: nginx_update

        - name: Set update status
          ansible.builtin.set_fact:
            stack_deploy:
              changed: true
              
      when: stack_exists.rc == 0

    - name: Wait for services to stabilize
      ansible.builtin.pause:
        seconds: 45

    - name: Verify application services are running
      ansible.builtin.shell:
        cmd: |
          for service in nginx-waf turbogate redis; do
            replicas=$(docker service ls --filter name={{ stack_name }}_$service --format '{{.Replicas}}')
            if [ -z "$replicas" ]; then
              echo "ERROR: Service $service not found."
              exit 1
            fi
            running=$(echo $replicas | cut -d'/' -f1)
            desired=$(echo $replicas | cut -d'/' -f2)
            if [ "$running" != "$desired" ] || [ "$running" -lt "1" ]; then
              echo "ERROR: Service $service is not running correctly. Replicas: $replicas"
              docker service ps {{ stack_name }}_$service --no-trunc
              exit 1
            fi
            echo "✓ Service $service is running with replicas: $replicas"
          done
      register: service_check
      retries: 8
      delay: 15
      until: service_check.rc == 0

    - name: Final health check via Load Balancer
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/health"
        method: GET
        status_code: 200
        timeout: 15
        validate_certs: yes
      register: lb_https_health
      retries: 12
      delay: 15
      until: lb_https_health.status == 200

    - name: Clean up old versioned secrets and configs post-deployment
      ansible.builtin.shell:
        cmd: |
          # Clean up old secrets
          docker secret ls --format '{{.Name}}' | grep -E '^(turbogate_secret_key|redis_password)_v[0-9]+$' | grep -v "v{{ resource_version }}$" | xargs -r docker secret rm 2>/dev/null || true
          # Clean up old configs  
          docker config ls --format '{{.Name}}' | grep -E '^(modsecurity_config|modsecurity_rules|nginx_backend_config)_v[0-9]+$' | grep -v "v{{ resource_version }}$" | xargs -r docker config rm 2>/dev/null || true
      when: stack_deploy.changed
      ignore_errors: yes
      changed_when: false

    - name: Display deployment summary
      ansible.builtin.debug:
        msg: |
          ✅ DEPLOYMENT COMPLETE ✅
          Stack: {{ stack_name }}
          Domain: https://{{ domain_name }}
          Access URL: https://{{ domain_name }}/health
          Resource Version: {{ resource_version }}
          Deployment Type: {{ 'New Deployment' if stack_exists.rc != 0 else 'Rolling Update' }} | grep -v "v{{ resource_version }}$" | xargs -r docker config rm 2>/dev/null || true
      when: stack_deploy.changed
      ignore_errors: yes
      changed_when: false

    - name: Display deployment summary
      ansible.builtin.debug:
        msg: |
          ✅ DEPLOYMENT COMPLETE ✅
          Stack: {{ stack_name }}
          Domain: https://{{ domain_name }}
          Access URL: https://{{ domain_name }}/health
          Resource Version: {{ resource_version }}
          Deployment Type: {{ 'New Deployment' if stack_exists.rc != 0 else 'Rolling Update' }}"
      register: stack_exists
      failed_when: false
      changed_when: false

    # --- SECRET MANAGEMENT ---
    - name: Create new versioned Docker secrets
      ansible.builtin.shell:
        cmd: "echo -n '{{ item.value }}' | docker secret create {{ item.name }}_v{{ resource_version }} -"
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true

    # Only try to create unversioned secrets if stack doesn't exist
    - name: Create unversioned secret aliases (new deployment only)
      ansible.builtin.shell:
        cmd: "echo -n '{{ item.value }}' | docker secret create {{ item.name }} -"
      loop:
        - { name: "turbogate_secret_key", value: "{{ secret_key }}" }
        - { name: "redis_password", value: "{{ redis_password }}" }
      no_log: true
      when: stack_exists.rc != 0
      ignore_errors: yes
      
    # --- CONFIG MANAGEMENT ---
    - name: Create ModSecurity configuration content in a temporary file
      ansible.builtin.copy:
        dest: "/tmp/modsecurity_{{ resource_version }}.conf"
        content: |
          SecRuleEngine {{ waf_rule_engine | default('On') }}
          SecRequestBodyAccess On
          SecResponseBodyAccess On
          SecResponseBodyMimeType text/plain text/html text/xml application/json
          SecResponseBodyLimit 524288
          SecResponseBodyLimitAction ProcessPartial
          SecAuditEngine {{ waf_audit_engine | default('RelevantOnly') }}
          SecAuditLogRelevantStatus "^(?:5|4(?!04))"
          SecAuditLogParts ABDEFHIJZ
          SecAuditLogType Serial
          SecAuditLog /var/log/nginx/modsec_audit.log

    - name: Create ModSecurity rules content in a temporary file
      ansible.builtin.copy:
        dest: "/tmp/modsecurity_rules_{{ resource_version }}.conf"
        content: |
          Include /etc/nginx/modsecurity/modsecurity.conf
          Include /usr/local/owasp-modsecurity-crs/crs-setup.conf
          Include /usr/local/owasp-modsecurity-crs/rules/*.conf
          SecRule REQUEST_URI "@beginsWith /health" "id:1000,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecRule REQUEST_URI "@beginsWith /waf-health" "id:1001,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecRule REQUEST_URI "@beginsWith /lb-health" "id:1002,phase:1,pass,nolog,ctl:ruleEngine=Off"
          SecAction "id:900000,phase:1,nolog,pass,t:none,setvar:tx.paranoia_level={{ waf_paranoia_level | default(2) }}"
          SecAction "id:900001,phase:1,nolog,pass,t:none,setvar:tx.inbound_anomaly_score_threshold={{ waf_anomaly_inbound | default(10) }},setvar:tx.outbound_anomaly_score_threshold={{ waf_anomaly_outbound | default(8) }}"

    - name: Create backend NGINX config content from template
      ansible.builtin.template:
        src: nginx-waf.conf.j2
        dest: "/tmp/nginx-waf_{{ resource_version }}.conf"
        mode: '0644'

    - name: Create versioned configs
      ansible.builtin.command: "docker config create {{ item.name }}_v{{ resource_version }} {{ item.path }}"
      loop:
        - { name: "modsecurity_config", path: "/tmp/modsecurity_{{ resource_version }}.conf" }
        - { name: "modsecurity_rules", path: "/tmp/modsecurity_rules_{{ resource_version }}.conf" }
        - { name: "nginx_backend_config", path: "/tmp/nginx-waf_{{ resource_version }}.conf" }

    # Only create unversioned configs for new deployments
    - name: Create unversioned config aliases (new deployment only)
      ansible.builtin.command: "docker config create {{ item.name }} {{ item.path }}"
      loop:
        - { name: "modsecurity_config", path: "/tmp/modsecurity_{{ resource_version }}.conf" }
        - { name: "modsecurity_rules", path: "/tmp/modsecurity_rules_{{ resource_version }}.conf" }
        - { name: "nginx_backend_config", path: "/tmp/nginx-waf_{{ resource_version }}.conf" }
      when: stack_exists.rc != 0
      ignore_errors: yes
    
    - name: Clean up temporary config files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop:
        - "/tmp/modsecurity_{{ resource_version }}.conf"
        - "/tmp/modsecurity_rules_{{ resource_version }}.conf"
        - "/tmp/nginx-waf_{{ resource_version }}.conf"

    # ===================================================================
    # END: ZERO-DOWNTIME SECRET & CONFIG MANAGEMENT
    # ===================================================================

    - name: Create overlay networks if not exist
      community.docker.docker_network:
        name: "{{ item }}"
        driver: overlay
        attachable: yes
      loop:
        - turbogate_frontend
        - turbogate_backend
        - turbogate_database

    - name: Create Docker Compose file from template
      ansible.builtin.template:
        src: docker-compose-waf.yml.j2
        dest: "{{ compose_file }}"
        mode: '0644'
        backup: yes

    # Proper deployment strategy
    - name: Deploy Docker stack (new deployment)
      community.docker.docker_stack:
        name: "{{ stack_name }}"
        compose:
          - "{{ compose_file }}"
        state: present
        prune: no  # Don't prune on updates
      register: stack_deploy
      when: stack_exists.rc != 0

    # Rolling update for existing deployment
    - name: Perform rolling update for existing stack
      block:
        - name: Update turbogate service with new secrets
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --secret-rm turbogate_secret_key \
                --secret-add source=turbogate_secret_key_v{{ resource_version }},target=SECRET_KEY \
                --secret-rm redis_password \
                --secret-add source=redis_password_v{{ resource_version }},target=redis_password \
                --update-parallelism 1 \
                --update-delay 30s \
                --update-order start-first \
                {{ stack_name }}_turbogate
          register: turbogate_update

        - name: Update redis service with new password
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --secret-rm redis_password \
                --secret-add source=redis_password_v{{ resource_version }},target=redis_password \
                --update-parallelism 1 \
                --update-delay 30s \
                {{ stack_name }}_redis
          register: redis_update

        - name: Update nginx-waf service with new configs
          ansible.builtin.shell:
            cmd: |
              docker service update \
                --config-rm modsecurity_config \
                --config-add source=modsecurity_config_v{{ resource_version }},target=/etc/nginx/modsecurity/modsecurity.conf \
                --config-rm modsecurity_rules \
                --config-add source=modsecurity_rules_v{{ resource_version }},target=/etc/nginx/modsecurity/main.conf \
                --config-rm nginx_backend_config \
                --config-add source=nginx_backend_config_v{{ resource_version }},target=/etc/nginx/nginx.conf \
                --update-parallelism 1 \
                --update-delay 30s \
                {{ stack_name }}_nginx-waf
          register: nginx_update

        - name: Set update status
          ansible.builtin.set_fact:
            stack_deploy:
              changed: true
              
      when: stack_exists.rc == 0

    - name: Wait for services to stabilize
      ansible.builtin.pause:
        seconds: 45

    - name: Verify application services are running
      ansible.builtin.shell:
        cmd: |
          for service in nginx-waf turbogate redis; do
            replicas=$(docker service ls --filter name={{ stack_name }}_$service --format '{{.Replicas}}')
            if [ -z "$replicas" ]; then
              echo "ERROR: Service $service not found."
              exit 1
            fi
            running=$(echo $replicas | cut -d'/' -f1)
            desired=$(echo $replicas | cut -d'/' -f2)
            if [ "$running" != "$desired" ] || [ "$running" -lt "1" ]; then
              echo "ERROR: Service $service is not running correctly. Replicas: $replicas"
              docker service ps {{ stack_name }}_$service --no-trunc
              exit 1
            fi
            echo "✓ Service $service is running with replicas: $replicas"
          done
      register: service_check
      retries: 8
      delay: 15
      until: service_check.rc == 0

    - name: Final health check via Load Balancer
      ansible.builtin.uri:
        url: "https://{{ domain_name }}/health"
        method: GET
        status_code: 200
        timeout: 15
        validate_certs: yes
      register: lb_https_health
      retries: 12
      delay: 15
      until: lb_https_health.status == 200

    - name: Clean up old versioned secrets and configs post-deployment
      ansible.builtin.shell:
        cmd: |
          # Clean up old secrets
          docker secret ls --format '{{.Name}}' | grep -E '^(turbogate_secret_key|redis_password)_v[0-9]+$' | grep -v "v{{ resource_version }}$" | xargs -r docker secret rm 2>/dev/null || true
          # Clean up old configs  
          docker config ls --format '{{.Name}}' | grep -E '^(modsecurity_config|modsecurity_rules|nginx_backend_config)_v[0-9]+$' | grep -v "v{{ resource_version }}$" | xargs -r docker config rm 2>/dev/null || true
      when: stack_deploy.changed
      ignore_errors: yes
      changed_when: false

    - name: Display deployment summary
      ansible.builtin.debug:
        msg: |
          ✅ DEPLOYMENT COMPLETE ✅
          Stack: {{ stack_name }}
          Domain: https://{{ domain_name }}
          Access URL: https://{{ domain_name }}/health
          Resource Version: {{ resource_version }}
          Deployment Type: {{ 'New Deployment' if stack_exists.rc != 0 else 'Rolling Update' }}