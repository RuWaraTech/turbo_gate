name: CI - Turbo Gate
on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ "**" ]

env:
  IMAGE_NAME: fwande/turbogate
  REGISTRY_CACHE_NAME: fwande/turbogate-cache
  POETRY_VERSION: 1.8.3

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: üß± Checkout Code
      uses: actions/checkout@v4
    
    - name: üîç Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH'
    
    - name: üì§ Upload Trivy scan results to GitHub Security
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  build:
    runs-on: ubuntu-latest
    outputs:
      duration: ${{ steps.duration.outputs.duration }}
      status: ${{ job.status }}

    steps:
    - name: üïí Start Timer
      id: timer
      run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

    - name: üß± Checkout Code
      uses: actions/checkout@v4

    - name: üê≥ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          image=moby/buildkit:v0.12.0
          network=host

    - name: üîß Build Test Image
      uses: docker/build-push-action@v5
      with:
        context: .
        target: test
        load: true
        tags: ${{ env.IMAGE_NAME }}:test
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          POETRY_VERSION=1.8.3

    - name: üß™ Run Tests with Coverage
      run: |
        # Run tests and capture exit code
        docker run --rm ${{ env.IMAGE_NAME }}:test 
          
        
    - name: üîß Build Production Image
      uses: docker/build-push-action@v5
      with:
        context: .
        target: prod
        load: true
        tags: ${{ env.IMAGE_NAME }}:prod
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          POETRY_VERSION=1.8.3

    - name: üèÉ Run Production Container and Health Check
      run: |
        # Start container with resource limits
        docker run --rm -d \
          -p 5000:5000 \
          --name turbogate_prod \
          --memory="512m" \
          --cpus="1" \
          -e PYTHONUNBUFFERED=1 \
          ${{ env.IMAGE_NAME }}:prod
        
        # Wait for health check to pass (Dockerfile already has HEALTHCHECK)
        echo "‚è≥ Waiting for container to be healthy..."
        timeout 60s bash -c '
          until [ "$(docker inspect -f {{.State.Health.Status}} turbogate_prod)" == "healthy" ]; do
            echo "Container health: $(docker inspect -f {{.State.Health.Status}} turbogate_prod)"
            sleep 2
          done
        '
        
        # Additional verification with more detailed output
        echo "‚úÖ Container is healthy, performing additional checks..."
        curl -v --retry 3 --retry-delay 2 --fail http://localhost:5000/gateway/health
        
        # Check container logs for any startup errors
        echo "üìã Container logs:"
        docker logs turbogate_prod --tail 20

    - name: üõë Stop Production Container
      if: always()
      run: docker stop turbogate_prod || true

    - name: ‚è±Ô∏è Calculate duration
      id: duration
      if: always()
      run: |
        end_time=$(date +%s)
        duration=$((end_time - ${{ steps.timer.outputs.start_time }}))
        echo "duration=${duration}" >> $GITHUB_OUTPUT


  discord-notify:
    needs: build
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Extract commit info
        id: commit-info
        run: |
          # Handle empty commit message
          COMMIT_MSG="${{ github.event.head_commit.message || 'No commit message' }}"
          FIRST_LINE=$(echo "$COMMIT_MSG" | head -n 1 | sed 's/"/\\"/g')
          echo "first_line=${FIRST_LINE}" >> $GITHUB_OUTPUT
          
          # Set author based on event type
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "pr_text=PR #${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "author=${{ github.event.pull_request.user.login }}" >> $GITHUB_OUTPUT
          else
            echo "pr_text=Push" >> $GITHUB_OUTPUT
            echo "author=${{ github.actor }}" >> $GITHUB_OUTPUT
          fi

      - name: Validate and send Discord notification
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK }}
        run: |
          # Validate webhook exists
          if [ -z "$WEBHOOK_URL" ]; then
            echo "‚ö†Ô∏è Discord webhook not configured"
            exit 0
          fi

          # Set status variables
          if [ "${{ needs.build.result }}" == "success" ]; then
            STATUS_EMOJI="‚úÖ"
            STATUS_TEXT="Success"
            COLOR="65280" # Green
          else
            STATUS_EMOJI="‚ùå"
            STATUS_TEXT="Failure"
            COLOR="16711680" # Red
          fi

          # Create safe JSON payload using jq
          PAYLOAD=$(jq -n \
            --arg title "TurboGate CI $STATUS_TEXT" \
            --arg status "$STATUS_EMOJI $STATUS_TEXT" \
            --arg repo "${{ github.repository }}" \
            --arg branch "${{ github.ref_name }}" \
            --arg author "@${{ steps.commit-info.outputs.author }}" \
            --arg trigger "${{ steps.commit-info.outputs.pr_text }}" \
            --arg commit "[${GITHUB_SHA:0:7}](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})" \
            --arg message "${{ steps.commit-info.outputs.first_line }}" \
            --arg workflow "[${{ github.workflow }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" \
            --arg duration "${{ needs.build.outputs.duration }} seconds" \
            --argjson color "$COLOR" \
            '{
              embeds: [{
                title: $title,
                description: (
                  "**Status**: \($status)\n" +
                  "**Repository**: `\($repo)`\n" +
                  "**Branch**: `\($branch)`\n" +
                  "**Author**: \($author)\n" +
                  "**Trigger**: \($trigger)\n" +
                  "**Commit**: \($commit)\n" +
                  "**Message**: \($message)\n" +
                  "**Workflow**: \($workflow)\n" +
                  "**Duration**: \($duration)\n" +
                  "**Runner**: ubuntu-latest"
                ),
                color: $color,
                timestamp: now|strftime("%Y-%m-%dT%H:%M:%SZ"),
                footer: {
                  text: "GitHub Actions",
                  icon_url: "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
                }
              }],
              username: "GitHub CI Bot",
              avatar_url: "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"
            }')

          # Send with error handling
          curl -sS -X POST \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            "$WEBHOOK_URL" || echo "Failed to send Discord notification"
